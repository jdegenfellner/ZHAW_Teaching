p <- seq(
from = 0,
to = 1,
length.out = 100
)
# Probability of making the right decision (depending on p) ----
prob_truth_f <- function(p) {
(p * (1 - alpha) + (1 - p) * (1 - beta)) / (p * (1 - alpha) + (1 - p) * (1 - beta) + p * alpha + (1 - p) * beta)
}
df <- data.frame(p = p, prob_truth = prob_truth_f(p))
df %>% ggplot(aes(x = p, y = prob_truth)) +
geom_line() +
ggtitle("Probability to make the correct decision") +
theme(plot.title = element_text(hjust = 0.5))
# Example -----
# if you do not have any clue about p, let us assume p = 0.5
# Probability, to make the wrong decision is:
1 - prob_truth_f(p = 0.5) # Many people would think it is 5%
(1 - alpha + 1- beta)/(1 - alpha + 1- beta + alpha + beta)
# Irrespective of p, looking at the 4 possible decisions,
# the probability of a incorrect decision would be:
1 - (1 - alpha + 1- beta)/(1 - alpha + 1- beta + alpha + beta)
library(pacman)
p_load(tidyverse)
# Set working directory to source file location
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
# Generiere eine sample aus einer Zufallszahl (wir wissen hier, wie diese----
# verteilt ist):
n <- 10000
x <- rnorm(n, mean = 23.4, sd = 5.6)
df <- data.frame(values = x)
p2 <- ggplot(df, aes(x = values)) +
geom_histogram(aes(y = after_stat(density)), bins = 30, alpha = 0.7, color="darkgrey") +
geom_density(aes(y = after_stat(density)), color = "blue", size=1) +
geom_boxplot(aes(y = -0.01, x = values), width = 0.02, position = position_nudge(y = -0.00)) +
geom_point(aes(y = -0.01),
position = position_jitter(width = 0.002, height = 0.01),
size = 1, alpha = 0.05) +
ggtitle("Histogram with density plot and boxplot below") +
theme(plot.title = element_text(hjust = 0.5))
p2
# Schaetzer 1: arithmetisches Mittel
(x1 <- mean(x)) # not bad
abs(x1-23.4) # abs. Fehler: z.B. 0.0551746
# Schaetzer 2: Mittelwert aus groesster und kleinster Beobachtung
(x2 <- mean(c(min(x), max(x))))
abs(x2-23.4) # abs. Fehler: z.B. 0.5289857
abs(x2-23.4)/abs(x1-23.4) # z.B. 66 mal so gross.
# Set the seed for reproducibility
set.seed(0)
estimate_means <- function(n) {
x <- rnorm(n, mean = 23.4, sd = 5.6)
x1 <- mean(x)
x2 <- mean(c(min(x), max(x)))
return(c(x1, x2))
}
# Perform the process n_sim times and store the results
n_sim <- 1000
estimates <- replicate(n_sim, estimate_means(n))
estimates_df <- as.data.frame(t(estimates))
colnames(estimates_df) <- c("arithm_Mittel", "Mittelwert_Min_Max")
# _Schaetzer 1:----
# aus Simulation:
(std_dev_x1 <- sd(estimates_df$arithm_Mittel))
# vgl. Standardfehler laut Formel se(\bar{X} = \frac{s}{\sqrt(n)})
sd(x)/sqrt(length(x)) # very close (hier wurde nur eine sample genommen)
# _Schaetzer 2:----
(std_dev_x2 <- sd(estimates_df$Mittelwert_Min_Max))
sd(x)/sqrt(2) # wrong, why?
# Convert the data frame to long format using pivot_longer from the tidyr package
estimates_long <- pivot_longer(estimates_df, cols = everything(), names_to = "Estimator", values_to = "Estimate")
ggplot(estimates_long, aes(x = Estimate, fill = Estimator)) +
geom_histogram(aes(y = after_stat(density)), position = 'identity', alpha = 0.7, bins = 30) +
facet_wrap(~Estimator, scales = 'free_y') +
theme_minimal() +
labs(title = paste0("n_sample = ",n,"; ","n_sim = ",n_sim),
x = "Estimated Value",
y = "Density") +
theme(plot.title = element_text(hjust = 0.5)) +
annotate("text", x = Inf, y = Inf, label = sprintf("Std.fehler arithm.Mittel: %0.2f", std_dev_x1),
hjust = 1.1, vjust = 2, size = 3.5, color = "red") +
annotate("text", x = Inf, y = Inf, label = sprintf("Std.fehler MinMax: %0.2f", std_dev_x2),
hjust = 1.1, vjust = 1, size = 3.5, color = "blue") +
theme(plot.title = element_text(hjust = 0.5))
# Set working directory to source file location
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
library(pacman)
p_load(tidyverse)
# Einstellbare Parameter
sample_size <- 70   # Größe einer Stichprobe
repetitions <- 5000 # Anzahl der Wiederholungen
# Parameter der Gamma-Verteilung
shape <- 2 # Formparameter
rate <- 1  # Ratenparameter
# Erwartungswert (Mittelwert) und Standardabweichung der Gamma-Verteilung
mu <- shape / rate
sigma <- sqrt(shape / (rate ^ 2))
# Original-Gamma-Verteilung plotten
gamma_data <- rgamma(10000, shape = shape, rate = rate)
df_gamma <- data.frame(gamma_data)
ggplot(df_gamma, aes(x = gamma_data)) +
geom_histogram(aes(y = ..density..), bins = 50, fill = "blue", alpha = 0.7) +
ggtitle(paste("Gamma-Verteilung mit Shape", shape, "und Rate", rate)) +
xlab("Wert") +
ylab("Dichte") +
theme_minimal()
# Leerer Vektor für die Speicherung der Z-Werte
z_values <- c()
# Simulierung
for (i in 1:repetitions) {
sample_data <- rgamma(sample_size, shape = shape, rate = rate)  # Ziehen einer Stichprobe
sample_mean <- mean(sample_data)                                # Mittelwert der Stichprobe
# Z-Wert berechnen
z_value <- (sample_mean - mu) / (sigma / sqrt(sample_size))
# Z-Wert in den Vektor hinzufügen
z_values <- c(z_values, z_value)
}
# Daten für ggplot vorbereiten
df <- data.frame(z_values)
# Plot erstellen
ggplot(df, aes(x = z_values)) +
geom_histogram(aes(y = after_stat(density)), bins = 50, fill = "blue", alpha = 0.7) +
stat_function(fun = dnorm, args = list(mean = 0, sd = 1), color = "red", size = 1) +
ggtitle(paste0("Zentrale Grenzverteilung: Illustration mit Gamma-Verteilung, n="),repetitions) +
xlab(expression((bar(x) - mu) / (sigma / sqrt(n)))) +
ylab("Dichte") +
theme_minimal() +
theme(plot.background = element_rect(fill = "white"))
# Set working directory to source file location
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
library(pacman)
#install.packages("BEST_0.5.4.tar.gz", repos = NULL, type = "source") # Not available on current CRAN
p_load(HDInterval, BEST, tictoc, psych)
?BEST
?BESTpower # Estimation of the probability of meeting the goals of a study
(y1 <- c(-.5,0,1.2,1.2,1.2,1.9,2.4,3)*100)
(y2 <- c(-1.2,-1.2,-.5,0,0,.5,1.1,1.9)*100)
data <- data.frame(y1,y2)
psych::describe(data)
t.test(y1, y2, mu = 0, var.equal = FALSE) # mu: a number indicating the true value of the mean (or difference in means if you are performing a two sample test).
t.test(y1, y2, mu = 0) # takes the correct t-Test automatically
# H_0: mue1 - mue2 = delta_0
a <- 20 # ROPE (region of practical equivalence)
d_0 <- 0  # delta_0 # der praktisch relevante Unterschied muss groesser als 20 sein!
tic()
BESTout <- BESTmcmc(y1, y2, verbose=TRUE) # numSavedSteps = 1e+05
toc() # 2s
par(bg = "yellow")
pairs(BESTout)
summary(BESTout, ROPEm = c(-a+d_0, c+d_0), compValm = c, digits = 5) # summary.BEST()
par(bg = "yellow")
plot(BESTout, which = "mean", compVal = d_0, ROPE = c(-a+d_0, d_0+a), showCurve = FALSE) # wäre d_0>0, würde sich das rot markierten Intervall nach rechts verschieben (eine bestimme Differenz wird also über den Zufall hinaus gefordert)
par(bg = "yellow")
plot(BESTout, which = "effect", showCurve = FALSE) # jetzt betrachtet man statt den posterior means eine transformierte Groesse (effect size)
# Try other posteriors...
# Info_ match.arg(which) : 'arg' should be one of “mean”, “sd”, “effect”, “nu”
par(bg = "yellow")
plot(BESTout, which = "mean", showCurve = FALSE)
plot(BESTout, which = "mean", showCurve = FALSE)
# Irrespective of p, looking at the 4 possible decisions,
# the probability of a incorrect decision would be:
1 - (1 - alpha + 1 - beta)/(1 - alpha + 1- beta + alpha + beta)
library(pacman)
p_load(tidyverse)
# Set working directory to source file location
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
# Generiere eine sample aus einer Zufallszahl (wir wissen hier, wie diese----
# verteilt ist):
n <- 10000
x <- rnorm(n, mean = 23.4, sd = 5.6)
df <- data.frame(values = x)
p2 <- ggplot(df, aes(x = values)) +
geom_histogram(aes(y = after_stat(density)), bins = 30, alpha = 0.7, color="darkgrey") +
geom_density(aes(y = after_stat(density)), color = "blue", size=1) +
geom_boxplot(aes(y = -0.01, x = values), width = 0.02, position = position_nudge(y = -0.00)) +
geom_point(aes(y = -0.01),
position = position_jitter(width = 0.002, height = 0.01),
size = 1, alpha = 0.05) +
ggtitle("Histogram with density plot and boxplot below") +
theme(plot.title = element_text(hjust = 0.5))
p2
library(pacman)
p_load(DiagrammeR, data.tree, tidyverse)
# Create the tree structure
tree <- Node$new("H_0 True?")
tree$AddChild("P")
tree$AddChild("1-P")
tree$children[[1]]$AddChild("1-alpha")
tree$children[[1]]$AddChild("alpha")
tree$children[[2]]$AddChild("1-beta")
tree$children[[2]]$AddChild("beta")
graph <- ToDiagrammeRGraph(tree)
render_graph(graph)
alpha <- 0.05 # Type I decision probability
beta <- 0.2 # 1 - Power
# Probability that the H_0 is true
p <- seq(
from = 0,
to = 1,
length.out = 100
)
# Probability of making the right decision (depending on p) ----
prob_truth_f <- function(p) {
(p * (1 - alpha) + (1 - p) * (1 - beta)) / (p * (1 - alpha) + (1 - p) * (1 - beta) + p * alpha + (1 - p) * beta)
}
df <- data.frame(p = p, prob_truth = prob_truth_f(p))
df %>% ggplot(aes(x = p, y = prob_truth)) +
geom_line() +
ggtitle("Probability to make the correct decision") +
theme(plot.title = element_text(hjust = 0.5))
# Note, the denominator simplifies to 1.
prob_truth_f_simpl(p){
# Note, the denominator simplifies to 1.
prob_truth_f_simpl <- function (p){
1+p*(1-alpha+beta)
}
alpha <- 0.05 # Type I decision probability
beta <- 0.2 # 1 - Power
# Probability that the H_0 is true
p <- seq(
from = 0,
to = 1,
length.out = 100
)
# Probability of making the right decision (depending on p) ----
prob_truth_f <- function(p) {
(p * (1 - alpha) + (1 - p) * (1 - beta)) / (p * (1 - alpha) + (1 - p) * (1 - beta) + p * alpha + (1 - p) * beta)
}
# Note, the denominator simplifies to 1.
prob_truth_f_simpl <- function (p){
1+p*(1-alpha+beta)
}
df <- data.frame(p = p, prob_truth = prob_truth_f(p), prob_truth_simpl <- prob_truth_f_simpl(p)
df <- data.frame(p = p,
df <- data.frame(p = p,
prob_truth = prob_truth_f(p),
prob_truth_simpl = prob_truth_f_simpl(p))
df %>% ggplot(aes(x = p, y = prob_truth)) +
geom_line() +
ggtitle("Probability to make the correct decision") +
theme(plot.title = element_text(hjust = 0.5))
df %>% ggplot(aes(x = p, y = prob_truth)) +
geom_line() +
geom_point(prob_truth_simpl) +
ggtitle("Probability to make the correct decision") +
theme(plot.title = element_text(hjust = 0.5))
df %>% ggplot(aes(x = p, y = prob_truth)) +
geom_line() +
geom_point(df$prob_truth_simpl) +
ggtitle("Probability to make the correct decision") +
theme(plot.title = element_text(hjust = 0.5))
df <- data.frame(p = p,
prob_truth = prob_truth_f(p),
prob_truth_simpl = prob_truth_f_simpl(p))
df %>% ggplot(aes(x = p, y = prob_truth)) +
geom_line() +
geom_point(df$prob_truth_simpl) +
ggtitle("Probability to make the correct decision") +
theme(plot.title = element_text(hjust = 0.5))
# Note, the denominator simplifies to 1.
prob_truth_f_simpl <- function (p){
1 + p*(2 - alpha + beta)
}
df <- data.frame(p = p,
prob_truth = prob_truth_f(p),
prob_truth_simpl = prob_truth_f_simpl(p))
ggplot(df, aes(x = p)) +
geom_line(aes(y = prob_truth), color = "blue") +  # Line for prob_truth
geom_point(aes(y = prob_truth_simpl), color = "red") +  # Points for prob_truth_simpl
ggtitle("Probability to make the correct decision") +
theme(plot.title = element_text(hjust = 0.5))
# Note, the denominator simplifies to 1.
prob_truth_f_simpl <- function (p){
1 + p*(2 - alpha + beta)
}
df <- data.frame(p = p,
prob_truth = prob_truth_f(p),
prob_truth_simpl = prob_truth_f_simpl(p))
ggplot(df, aes(x = p)) +
geom_line(aes(y = prob_truth), color = "blue") +  # Line for prob_truth
geom_point(aes(y = prob_truth_simpl), color = "red") +  # Points for prob_truth_simpl
ggtitle("Probability to make the correct decision") +
theme(plot.title = element_text(hjust = 0.5))
# Note, the denominator simplifies to 1.
prob_truth_f_simpl <- function (p){
1 + p*(beta - alpha) - beta
}
df <- data.frame(p = p,
prob_truth = prob_truth_f(p),
prob_truth_simpl = prob_truth_f_simpl(p))
ggplot(df, aes(x = p)) +
geom_line(aes(y = prob_truth), color = "blue") +  # Line for prob_truth
geom_point(aes(y = prob_truth_simpl), color = "red") +  # Points for prob_truth_simpl
ggtitle("Probability to make the correct decision") +
theme(plot.title = element_text(hjust = 0.5))
ggplot(df, aes(x = p)) +
geom_line(aes(y = prob_truth), color = "blue") +  # Line for prob_truth
geom_point(aes(y = prob_truth_simpl), color = "red", size=0.2) +  # Points for prob_truth_simpl
ggtitle("Probability to make the correct decision") +
theme(plot.title = element_text(hjust = 0.5))
ggplot(df, aes(x = p)) +
geom_line(aes(y = prob_truth), color = "blue", size=1) +  # Line for prob_truth
geom_point(aes(y = prob_truth_simpl), color = "red", size=0.2) +  # Points for prob_truth_simpl
ggtitle("Probability to make the correct decision") +
theme(plot.title = element_text(hjust = 0.5))
df <- data.frame(p = p,
prob_truth = prob_truth_f(p),
prob_truth_simpl = prob_truth_f_simpl(p))
ggplot(df, aes(x = p)) +
geom_line(aes(y = prob_truth), color = "blue", size=1) +
geom_point(aes(y = prob_truth_simpl), color = "red", size=0.2) +
ggtitle("Probability to make the correct decision") +
theme(plot.title = element_text(hjust = 0.5))
library(pacman) # installs the package if necessary and loads it for use.
pacman::p_load(psych, lme4, GGally, readxl, writexl, tidyverse, DescTools)
options(scipen=999)
# Set working directory----
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) #  to source file location
# 1 Reliabilität --------
df <- read_excel("chapter 5_1_book_random50_LONG.xlsx") # long format
head(df)
str(df)
mean(df[df$Rater==1,]$ROM) - mean(df[df$Rater==2,]$ROM) # Mary and Peter rate differently on average
df_wide <- df %>% # pipe-operator
pivot_wider(names_from = Rater, values_from = ROM)
colnames(df_wide) <- c("patcode", "ROM_Mary", "ROM_Peter")
df_wide
res <- psych::ICC(df_wide[,-1])
res$results
res$lme
library(pacman)
p_load(DiagrammeR, data.tree, tidyverse)
# GPT4:
# Create the tree structure
tree <- Node$new("H_0 True?")
tree$AddChild("P")
tree$AddChild("1-P")
tree$children[[1]]$AddChild("1-alpha")
tree$children[[1]]$AddChild("alpha")
tree$children[[2]]$AddChild("1-beta")
tree$children[[2]]$AddChild("beta")
graph <- ToDiagrammeRGraph(tree)
render_graph(graph)
alpha <- 0.05 # Type I decision probability
beta <- 0.2 # 1 - Power
# Probability that the H_0 is true
p <- seq(
from = 0,
to = 1,
length.out = 100
)
# Probability of making the right decision (depending on p) ----
prob_truth_f <- function(p) {
# Note that p is not the p-value, but the probability that H_0 is true
(p * (1 - alpha) + (1 - p) * (1 - beta)) / (p * (1 - alpha) + (1 - p) * (1 - beta) + p * alpha + (1 - p) * beta)
}
# Note, the denominator simplifies to 1:
prob_truth_f_simpl <- function (p){
1 + p*(beta - alpha) - beta
}
df <- data.frame(p = p,
prob_truth = prob_truth_f(p),
prob_truth_simpl = prob_truth_f_simpl(p))
ggplot(df, aes(x = p)) +
geom_line(aes(y = prob_truth), color = "blue", size=1) +
geom_point(aes(y = prob_truth_simpl), color = "red", size=0.2) +
ggtitle("Probability to make the correct decision") +
theme(plot.title = element_text(hjust = 0.5))
# Example -----
# if you do not have any clue about p, let us assume p = 0.5
# Probability, to make the wrong decision is:
1 - prob_truth_f(p = 0.5)
# Irrespective of p, looking at the 4 possible decisions,
# the probability of a incorrect decision would be:
1 - (1 - alpha + 1 - beta)/(1 - alpha + 1- beta + alpha + beta)
library(pacman)
p_load(DiagrammeR, data.tree, tidyverse)
# GPT4:
# Create the tree structure
tree <- Node$new("H_0 True?")
tree$AddChild("P")
tree$AddChild("1-P")
tree$children[[1]]$AddChild("1-alpha")
tree$children[[1]]$AddChild("alpha")
tree$children[[2]]$AddChild("1-beta")
tree$children[[2]]$AddChild("beta")
graph <- ToDiagrammeRGraph(tree)
render_graph(graph)
alpha <- 0.05 # Type I decision probability
beta <- 0.2 # 1 - Power
# Probability that the H_0 is true
p <- seq(
from = 0,
to = 1,
length.out = 100
)
p
p
# Probability of making the right decision (depending on p) ----
prob_truth_f <- function(p) {
# Note that p is not the p-value, but the probability that H_0 is true
(p * (1 - alpha) + (1 - p) * (1 - beta)) / (p * (1 - alpha) + (1 - p) * (1 - beta) + p * alpha + (1 - p) * beta)
}
# Note, the denominator simplifies to 1:
prob_truth_f_simpl <- function (p){
1 + p*(beta - alpha) - beta
}
df <- data.frame(p = p,
prob_truth = prob_truth_f(p),
prob_truth_simpl = prob_truth_f_simpl(p))
ggplot(df, aes(x = p)) +
geom_line(aes(y = prob_truth), color = "blue", size=1) +
geom_point(aes(y = prob_truth_simpl), color = "red", size=0.2) +
ggtitle("Probability to make the correct decision") +
theme(plot.title = element_text(hjust = 0.5))
# Example -----
# if you do not have any clue about p, let us assume p = 0.5
# Probability, to make the wrong decision is:
1 - prob_truth_f(p = 0.5)
library(pacman)
p_load(tidyverse)
# Set working directory to source file location
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
# Generiere eine sample aus einer Zufallszahl (wir wissen hier, wie diese----
# verteilt ist):
n <- 10000
x <- rnorm(n, mean = 23.4, sd = 5.6)
df <- data.frame(values = x)
p2 <- ggplot(df, aes(x = values)) +
geom_histogram(aes(y = after_stat(density)), bins = 30, alpha = 0.7, color="darkgrey") +
geom_density(aes(y = after_stat(density)), color = "blue", size=1) +
geom_boxplot(aes(y = -0.01, x = values), width = 0.02, position = position_nudge(y = -0.00)) +
geom_point(aes(y = -0.01),
position = position_jitter(width = 0.002, height = 0.01),
size = 1, alpha = 0.05) +
ggtitle("Histogram with density plot and boxplot below") +
theme(plot.title = element_text(hjust = 0.5))
p2
# Schaetzer 1: arithmetisches Mittel
(x1 <- mean(x)) # not bad
abs(x1-23.4) # abs. Fehler: z.B. 0.0551746
# Schaetzer 2: Mittelwert aus groesster und kleinster Beobachtung
(x2 <- mean(c(min(x), max(x))))
abs(x2-23.4) # abs. Fehler: z.B. 0.5289857
abs(x2-23.4)/abs(x1-23.4) # z.B. 66 mal so gross.
# Set the seed for reproducibility
set.seed(0)
estimate_means <- function(n) {
x <- rnorm(n, mean = 23.4, sd = 5.6)
x1 <- mean(x)
x2 <- mean(c(min(x), max(x)))
return(c(x1, x2))
}
# Perform the process n_sim times and store the results
n_sim <- 1000
estimates <- replicate(n_sim, estimate_means(n))
estimates_df <- as.data.frame(t(estimates))
colnames(estimates_df) <- c("arithm_Mittel", "Mittelwert_Min_Max")
# _Schaetzer 1:----
# aus Simulation:
(std_dev_x1 <- sd(estimates_df$arithm_Mittel))
# vgl. Standardfehler laut Formel se(\bar{X} = \frac{s}{\sqrt(n)})
sd(x)/sqrt(length(x)) # very close (hier wurde nur eine sample genommen)
# _Schaetzer 2:----
(std_dev_x2 <- sd(estimates_df$Mittelwert_Min_Max))
sd(x)/sqrt(2) # wrong, why?
# Convert the data frame to long format using pivot_longer from the tidyr package
estimates_long <- pivot_longer(estimates_df, cols = everything(), names_to = "Estimator", values_to = "Estimate")
ggplot(estimates_long, aes(x = Estimate, fill = Estimator)) +
geom_histogram(aes(y = after_stat(density)), position = 'identity', alpha = 0.7, bins = 30) +
facet_wrap(~Estimator, scales = 'free_y') +
theme_minimal() +
labs(title = paste0("n_sample = ",n,"; ","n_sim = ",n_sim),
x = "Estimated Value",
y = "Density") +
theme(plot.title = element_text(hjust = 0.5)) +
annotate("text", x = Inf, y = Inf, label = sprintf("Std.fehler arithm.Mittel: %0.2f", std_dev_x1),
hjust = 1.1, vjust = 2, size = 3.5, color = "red") +
annotate("text", x = Inf, y = Inf, label = sprintf("Std.fehler MinMax: %0.2f", std_dev_x2),
hjust = 1.1, vjust = 1, size = 3.5, color = "blue") +
theme(plot.title = element_text(hjust = 0.5))
# _Schaetzer 1:----
# aus Simulation:
(std_dev_x1 <- sd(estimates_df$arithm_Mittel))
# vgl. Standardfehler laut Formel se(\bar{X} = \frac{s}{\sqrt(n)})
sd(x)/sqrt(length(x)) # very close (hier wurde nur eine sample genommen)
pnorm(1.96, mean = 0, sd = 1)
pnorm(-1.96, mean = 0, sd = 1)
rnorm(1, mean = 0, sd = 1)
rnorm(1, mean = 0, sd = 1)
rnorm(1, mean = 0, sd = 1)
rnorm(1, mean = 0, sd = 1)
rnorm(1, mean = 0, sd = 1)
rnorm(1, mean = 0, sd = 1)
rnorm(1, mean = 0, sd = 1)
rnorm(1, mean = 0, sd = 1)
rnorm(1, mean = 0, sd = 1)
rnorm(1, mean = 0, sd = 1)
rnorm(1, mean = 0, sd = 1)
rnorm(1, mean = 0, sd = 1)
rnorm(1, mean = 0, sd = 1)
rnorm(1, mean = 0, sd = 1)
rnorm(1, mean = 0, sd = 1)
rnorm(1, mean = 0, sd = 1)
rnorm(1, mean = 0, sd = 1)
rnorm(1, mean = 0, sd = 1)
rnorm(1, mean = 0, sd = 1)
rnorm(1, mean = 0, sd = 1)
rnorm(1, mean = 0, sd = 1)
rnorm(1, mean = 0, sd = 1)
pnorm(2.2, mean = 0, sd = 1)
1- pnorm(2.2, mean = 0, sd = 1)
