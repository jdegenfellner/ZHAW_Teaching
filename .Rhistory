simrOptions(nsim = 200) # default 1000, change to a higher value in the end
power_simr <- powerSim(artificial_lmer, test = fixed("estradiol"))
power_simr
fixed_effects <-  c(intercept, beta_estr, beta_age)
# Random effects:
random_variance <- 25 # Variances/covariances for random effects. If there are multiple random effects, supply their parameters as a list.
artificial_lmer <- makeLmer(angle ~ estradiol + age + (1 | participant), # BMI + training_intensity + (BMI|ID) + (estradiol|participant)
fixef = fixed_effects,
VarCorr = random_variance,
sigma = 15, # highly sensitive (in power calculation). Needs work and a good reason for the level to be set!
data = data) # use artificial data set for simulation
# _Estradiol----
simrOptions(nsim = 200) # default 1000, change to a higher value in the end
power_simr <- powerSim(artificial_lmer, test = fixed("estradiol"))
power_simr
cor(data)
det(cor(data))
# Fixed effects:
fixed_effects <-  c(intercept, beta_estr, beta_age, beta_BMI) # adding BMI -> power 0
artificial_lmer <- makeLmer(angle ~ estradiol + age + BMI + (1 | participant), # BMI + training_intensity + (BMI|ID) + (estradiol|participant)
fixef = fixed_effects,
VarCorr = random_variance,
sigma = 15, # highly sensitive (in power calculation). Needs work and a good reason for the level to be set!
data = data) # use artificial data set for simulation
# _Estradiol----
simrOptions(nsim = 200) # default 1000, change to a higher value in the end
power_simr <- powerSim(artificial_lmer, test = fixed("estradiol"))
power_simr
install.packages("R6")
install.packages("curses")
library(devtools)
devtools::install_github('matloff/rcurses')
library(R6)
library(curses)
library(curses)
devtools::install_github('matloff/rcurses')
devtools::install_github('matloff/rcurses', force = TRUE)
library(R6)
library(curses)
install.packages("sys")
library(R6)
library(sys)
get_key <- function() {
if (sys::has_input()) {
key <- sys::read_input(1, raw = TRUE)
return(key)
}
return(NULL)
}
SnakeGame <- R6Class("SnakeGame",
# ... (the rest of the SnakeGame class remains the same)
)
play_snake_game <- function() {
game <- SnakeGame$new()
cat("\033[?25l")  # Hide cursor
on.exit({
cat("\033[?25h")  # Show cursor
})
while (TRUE) {
game$draw()
Sys.sleep(0.1)
key <- get_key()
if (!is.null(key)) {
new_direction <- switch(key,
"w" = "up",
"s" = "down",
"a" = "left",
"d" = "right",
NULL
)
if (!is.null(new_direction)) {
game$direction <- new_direction
}
}
if (!game$update()) {
break
}
}
cat("Game over!\n")
}
play_snake_game()
library(R6)
library(sys)
get_key <- function() {
if (sys::has_input()) {
key <- sys::read_input(1, raw = TRUE)
return(key)
}
return(NULL)
}
SnakeGame <- R6Class("SnakeGame",
# ... (the rest of the SnakeGame class remains the same)
)
play_snake_game <- function() {
game <- SnakeGame$new()
cat("\033[?25l")  # Hide cursor
on.exit({
cat("\033[?25h")  # Show cursor
})
while (TRUE) {
game$draw()
Sys.sleep(0.1)
key <- get_key()
if (!is.null(key)) {
new_direction <- switch(key,
"w" = "up",
"s" = "down",
"a" = "left",
"d" = "right",
NULL
)
if (!is.null(new_direction)) {
game$direction <- new_direction
}
}
if (!game$update()) {
break
}
}
cat("Game over!\n")
}
play_snake_game()
library(R6)
library(sys)
get_key <- function() {
if (sys::has_input()) {
key <- sys::read_input(1, raw = TRUE)
return(key)
}
return(NULL)
}
SnakeGame <- R6Class("SnakeGame",
# (the rest of the SnakeGame class remains the same)
public = list(
draw = function() {
cat("\033[2J")  # Clear screen
# Draw the border
cat("+", strrep("-", self$width), "+\n", sep = "")
for (i in 1:self$height) {
cat("|", strrep(" ", self$width), "|\n", sep = "")
}
cat("+", strrep("-", self$width), "+\n", sep = "")
# Draw the snake
for (part in self$snake) {
cat("\033[", part$y + 1, ";", part$x + 1, "H", "O", sep = "")
}
# Draw the food
cat("\033[", self$food$y + 1, ";", self$food$x + 1, "H", "*", sep = "")
# Print the points
cat("\033[", self$height + 3, ";1H", "Points: ", self$points, sep = "")
}
)
)
play_snake_game <- function() {
game <- SnakeGame$new()
cat("\033[?25l")  # Hide cursor
on.exit({
cat("\033[?25h")  # Show cursor
})
while (TRUE) {
game$draw()
Sys.sleep(0.1)
key <- get_key()
if (!is.null(key)) {
new_direction <- switch(key,
"w" = "up",
"s" = "down",
"a" = "left",
"d" = "right",
NULL
)
if (!is.null(new_direction)) {
game$direction <- new_direction
}
}
if (!game$update()) {
break
}
}
cat("Game over!\n")
}
play_snake_game()
play_snake_game()
library(R6)
library(sys)
get_key <- function() {
if (sys::has_input()) {
key <- sys::read_input(1, raw = TRUE)
return(key)
}
return(NULL)
}
SnakeGame <- R6Class("SnakeGame",
# (the rest of the SnakeGame class remains the same)
public = list(
draw = function() {
cat("\033[2J")  # Clear screen
# Draw the border
cat("+", strrep("-", self$width), "+\n", sep = "")
for (i in 1:self$height) {
cat("|", strrep(" ", self$width), "|\n", sep = "")
}
cat("+", strrep("-", self$width), "+\n", sep = "")
# Draw the snake
for (part in self$snake) {
cat("\033[", part$y + 1, ";", part$x + 1, "H", "O", sep = "")
}
# Draw the food
cat("\033[", self$food$y + 1, ";", self$food$x + 1, "H", "*", sep = "")
# Print the points
cat("\033[", self$height + 3, ";1H", "Points: ", self$points, sep = "")
}
)
)
play_snake_game <- function() {
game <- SnakeGame$new()
cat("\033[?25l")  # Hide cursor
on.exit({
cat("\033[?25h")  # Show cursor
})
while (TRUE) {
game$draw()
Sys.sleep(0.1)
key <- get_key()
if (!is.null(key)) {
new_direction <- switch(key,
"w" = "up",
"s" = "down",
"a" = "left",
"d" = "right",
NULL
)
if (!is.null(new_direction)) {
game$direction <- new_direction
}
}
if (!game$update()) {
break
}
}
cat("Game over!\n")
}
play_snake_game()
library(R6)
library(sys)
get_key <- function() {
if (sys::has_input()) {
key <- sys::read_input(1, raw = TRUE)
return(key)
}
return(NULL)
}
SnakeGame <- R6Class("SnakeGame",
# (the rest of the SnakeGame class remains the same)
public = list(
draw = function() {
cat("\033[2J")  # Clear screen
# Draw the border
cat("+", strrep("-", self$width), "+\n", sep = "")
for (i in 1:self$height) {
cat("|", strrep(" ", self$width), "|\n", sep = "")
}
cat("+", strrep("-", self$width), "+\n", sep = "")
# Draw the snake
for (part in self$snake) {
cat("\033[", part$y + 1, ";", part$x + 1, "H", "O", sep = "")
}
# Draw the food
cat("\033[", self$food$y + 1, ";", self$food$x + 1, "H", "*", sep = "")
# Print the points
cat("\033[", self$height + 3, ";1H", "Points: ", self$points, sep = "")
}
)
)
play_snake_game <- function() {
game <- SnakeGame$new()
cat("\033[?25l")  # Hide cursor
on.exit({
cat("\033[?25h")  # Show cursor
})
while (TRUE) {
game$draw()
Sys.sleep(0.1)
key <- get_key()
if (!is.null(key)) {
new_direction <- switch(key,
"w" = "up",
"s" = "down",
"a" = "left",
"d" = "right",
NULL
)
if (!is.null(new_direction)) {
game$direction <- new_direction
}
}
if (!game$update()) {
break
}
}
cat("Game over!\n")
}
play_snake_game()
# Code for tracking work hours at ZHAW #
# Especially single activities (work for projects, teaching and co)
# should be tracked in more detail to gain knowledge about my productivity
# Set working directory to source file location
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
# load packages-----------------------------------------------------------------
library(readxl)
library(tidyverse)
library(lubridate)
library(writexl)
# TODO
# Brutto/Netto-Arbeitszeit
# Dissertation optional inkludieren
# Soll/Ist vergleich mit ILV
# 1) READ (until first NA in column "KW")---------------------------------------
# Read function for multiple sheets
read_zeiterfassung <- function(sheets){
if(length(sheets) == 1){
ze <- read_xlsx("Zeitaufzeichnung.xlsx", sheet = sheets)
first_NA <- min(which(is.na(ze$KW)))
ze <- read_xlsx("Zeitaufzeichnung.xlsx", sheet = sheets, n_max = first_NA)
} else if (length(sheets) > 1) {
n <- length(sheets)
ze <- read_xlsx("Zeitaufzeichnung.xlsx", sheet = sheets[1])
first_NA <- min(which(is.na(ze$KW)))
ze <- read_xlsx("Zeitaufzeichnung.xlsx", sheet = sheets[1], n_max = first_NA)
for(i in 2:n){
ze_add <- read_xlsx("Zeitaufzeichnung.xlsx", sheet = sheets[i])
if( sum(is.na(ze_add$KW)) == 0 ) {
read_to <- dim(ze_add)[1]
} else {
read_to <- min(which(is.na(ze_add$KW)))
}
ze_add <- read_xlsx("Zeitaufzeichnung.xlsx", sheet = sheets[i], n_max = read_to)
ze <- rbind(ze, ze_add)
}
}
return(ze)
}
sheets = c("Jan23", "Feb23", "Mar23")
ze <- read_zeiterfassung(sheets = sheets)
# 2) ADAPT input----------------------------------------------------------------
ze <- ze %>% dplyr::select(-Dauer) %>%
mutate(Dauer = Ende - Beginn) %>%
relocate(Dauer, .after = Ende) %>%
mutate(Wochentag_label = lubridate::wday(Wochentag, label = TRUE)) %>%
relocate(Wochentag_label, .after = Wochentag) %>%
dplyr::select(-Wochentag)
if( attr(ze$Dauer, which = "units") == "hours" ){
ze$Dauer <- ze$Dauer*60
}
ze$Dauer_ohne_Pausen <- ifelse(ze$Taetigkeit_allg == "Mittag" |
ze$Taetigkeit_allg == "Pause"|
ze$Taetigkeit_allg == "Dissertation", 0, ze$Dauer)
# 3) Statistics-----------------------------------------------------------------
# __Daily hours ----------------------------------------------------------------
ze %>% group_by(Datum) %>%
summarise(Tagesarbeitszeit_ohne_Pausen = sum(Dauer_ohne_Pausen)/60) %>%
mutate(Wochentag = lubridate::wday(Datum, label = TRUE)) %>%
relocate(Wochentag, .after = Datum) %>% tail()
# Only weekdays:
#ze %>%
#  filter(Wochentag_label %in% c("Mon","Tue","Wed","Thu","Fri")) %>%
#  group_by(Datum) %>%
#  summarise(Tagesarbeitszeit_ohne_Pausen = sum(Dauer_ohne_Pausen, na.rm = TRUE)/60) %>%
# mutate(Wochentag = wday(Datum, label = TRUE)) %>%
#  relocate(Wochentag, .after = Datum) %>%
#  filter(Tagesarbeitszeit_ohne_Pausen > 0 )
# __Global mean, weekdays: ----
# TODO avearge working hours have to be calculated using ALL days but divide
# by the number of working days, otherwise work hours on weekends are lost.
ze %>%
filter(Wochentag_label %in% c("Mon","Tue","Wed","Thu","Fri")) %>%
group_by(Datum) %>%
summarise(Tagesarbeitszeit_ohne_Pausen = sum(Dauer_ohne_Pausen)/60) %>%
mutate(Wochentag = lubridate::wday(Datum, label = TRUE)) %>%
relocate(Wochentag, .after = Datum) %>%
filter(Tagesarbeitszeit_ohne_Pausen > 0) %>%
summarise(global_mean_workdays = mean(Tagesarbeitszeit_ohne_Pausen, na.rm = TRUE))
# # Global mean, weekdays (all):
# __Weekly h, Mo-Fr ------------------------------------------------------------
ze %>% group_by(KW) %>%
filter(Wochentag_label %in% c("Mon","Tue","Wed","Thu","Fri")) %>%
summarise(Wochenarbeitszeiten_ohne_Pausen = sum(Dauer_ohne_Pausen)/60)
# __Weekend hours --------------------------------------------------------------
#ze %>% group_by(KW) %>%
#  filter(Wochentag_label %in% c("Sat","Sun")) %>%
#  summarise(Wochenende_Arbeitszeiten_ohne_Pausen = sum(Dauer_ohne_Pausen)/60)
# BOOKING in Pro-Time ----------------------------------------------------------
(df <- ze %>% filter(Taetigkeit_allg != "Mittag",
Taetigkeit_allg != "Pause",
Taetigkeit_allg != "Dissertation") %>%
filter(month(Datum) == 3) %>% # Feb23
group_by(Taetigkeit_allg) %>%
summarise(Tagesarbeitszeit_ohne_Pausen = sum(Dauer_ohne_Pausen, na.rm = TRUE)/60))
filename <- paste0("summary_", "Mar23", ".xlsx")
write_xlsx(df, filename)
# total_work_time current month
ze %>% group_by(Taetigkeit_allg) %>%
filter(month(Datum) == 2) %>% # Feb
summarise(Tagesarbeitszeit_ohne_Pausen = sum(Dauer_ohne_Pausen, na.rm = TRUE)/60) %>%
summarise(total_work_time = sum(Tagesarbeitszeit_ohne_Pausen))
# Scheduled monthly working time:
soll <- 2103.53/12
# Jan23
jan23 <- 179
soll - jan23
# Feb23
feb23 <- 167
2*soll - jan23 - feb23 - 8.4 # 1 Holiday (Fasnacht) in Winterthur!
library(tidyverse)
library(pwr)
# Set working directory to source file location
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
# 1) Mini-Example from QM1 Script, p. 176---------------------------------------
power.t.test(delta = 0.5, sd = 1, power = 0.8, type = "two.sample", alternative = "one.sided")
# -> n = 50 required
n_required <- 50
# 1) Mini-Example from QM1 Script, p. 176---------------------------------------
power.t.test(delta = 0.5, sd = 1, power = 0.8, type = "two.sample", alternative = "one.sided")
# -> n = 50 required
n_required <- 50
?t.test
# __Check via simulation:----
n <- 1000
p_vals <- rep(NA, n)
for(i in 1:n){
x1 <- rnorm(n_required, mean = 2.5, sd = 1) # hence, effect size = (2.5 - 2.0)/1 = 0.5
x2 <- rnorm(n_required, mean = 2.0, sd = 1)
test <- t.test(x1, x2, alternative = "greater", paired = FALSE)
p_vals[i] <- test$p.value
}
sum(p_vals < 0.05)/n # = power --> worked!!
?power.t.test
# Check variants:
power.t.test(delta = 0.5, sd = 1, power = 0.8, type = "one.sample", alternative = "one.sided")
power.t.test(delta = 0.5, sd = 1, power = 0.8, type = "two.sample", alternative = "two.sided")
# Create power-curve manually:
n_required <- 10:100
length(n_required)
power_vec <- rep(0, length(n_required))
test <- power.t.test(delta = 0.5, sd = 1,, n = n_required[i], power = NULL, type = "two.sample", alternative = "one.sided")
test$power
test <- power.t.test(delta = 0.5, sd = 1, power = 0.8, type = "two.sample", alternative = "one.sided")
test$power
# Create power-curve manually:
n <- 10:100
# Create power-curve manually:
n <- 10:100
power_vec <- rep(0, length(n_required))
for(i in 1:length(n_required)){
test <- power.t.test(delta = 0.5, sd = 1, n = n, power = NULL, type = "two.sample", alternative = "one.sided")
power_vec[i] <- test$power
}
# Create power-curve manually:
n <- 10:100
power_vec <- rep(0, length(n_required))
for(i in 1:length(n_required)){
test <- power.t.test(delta = 0.5, sd = 1, n = n[i], power = NULL, type = "two.sample", alternative = "one.sided")
power_vec[i] <- test$power
}
df <- data.frame(n = n, power = power_vec)
df %>% ggplot(aes(x = n, y = power_vec)) +
geom_line()
df %>% ggplot(aes(x = n, y = power_vec)) +
geom_line() +
ggtitle("Power Curve for t-Test") +
theme(plot.title = element_text(hjust = 0.5))
df %>% ggplot(aes(x = n, y = power_vec)) +
geom_line() +
ggtitle("Power Curve for t-Test") +
theme(plot.title = element_text(hjust = 0.5)) +
ylab("Power")
df %>% ggplot(aes(x = n, y = power_vec)) +
geom_line() +
ggtitle("Power Curve for t-Test with varying sample size (n)") +
theme(plot.title = element_text(hjust = 0.5)) +
ylab("Power")
?seq
# Create Power curve for varying effect-size:
delta <- seq(from = 0.1, to = 0.9, by = 0.01)
# Create Power curve for varying effect-size:
delta <- seq(from = 0.1, to = 0.9, by = 0.01)
power_vec <- rep(0, length(delta))
# __Create Power curve for varying effect-size:----
delta <- seq(from = 0.1, to = 0.9, by = 0.01)
power_vec <- rep(0, length(delta))
for(i in 1:length(delta)){
test <- power.t.test(delta = delta[i], sd = 1, n = 50, power = NULL, type = "two.sample", alternative = "one.sided")
power_vec[i] <- test$power
}
for(i in 1:length(delta)){
test <- power.t.test(delta = delta[i], sd = 1, n = 50, power = NULL, type = "two.sample", alternative = "one.sided")
power_vec[i] <- test$power
}
df <- data.frame(delta = delta, power = power_vec)
df <- data.frame(delta = delta, power = power_vec)
df %>% ggplot(aes(x = delta, y = power_vec)) +
geom_line() +
ggtitle("Power Curve for t-Test with varying effect size (delta)") +
theme(plot.title = element_text(hjust = 0.5)) +
ylab("Power")
library(rgl)
library(tidyverse)
library(pwr)
library(rgl)
persp3D
install.packages("rgl")
library(rgl)
